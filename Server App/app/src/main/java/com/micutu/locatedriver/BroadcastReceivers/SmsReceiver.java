package com.micutu.locatedriver.BroadcastReceivers;

import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.telephony.SmsManager;
import android.telephony.SmsMessage;
import android.util.Base64;
import android.widget.Toast;

import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.Response;
import com.android.volley.VolleyError;
import com.android.volley.toolbox.StringRequest;
import com.android.volley.toolbox.Volley;
import com.micutu.locatedriver.MainActivity;
import com.micutu.locatedriver.R;
import com.micutu.locatedriver.Utilities.GetContents;
import com.micutu.locatedriver.Utilities.Permissions;

import java.util.ArrayList;

public class SmsReceiver extends BroadcastReceiver {
    private final static String TAG = SmsReceiver.class.getSimpleName();

    public SmsReceiver() {

    }


    /**
     * A function that gets called once a text message is received.
     * @param context
     * @param intent
     */
    @Override
    public void onReceive(Context context, Intent intent) {
        //Print in the debug text that we received some text message
        MainActivity.debugTextView.setText("Received something");

        //The word we need to find in the text message
        String keyword = "Approximate location";

        //Return if we don't have a keyword set.
        if (keyword.length() == 0) {
            return;
        }

        //Get the received text messages that contains the keyword.
        ArrayList<SmsMessage> list = null;
        try {
            list = getMessagesWithKeyword(keyword, intent.getExtras());
        } catch (Exception e) {
            return;
        }

        //Return if the received text message doesn't have the keyword we find
        if (list.size() == 0) {
            return;
        }

        //Ask permission if the user doesn't give the permission before.
        if (!Permissions.haveSendSMSAndLocationPermission(context)) {
            try {
                Permissions.setPermissionNotification(context);
            } catch (Exception e) {
                Toast.makeText(context, R.string.send_sms_and_location_permission, Toast.LENGTH_SHORT).show();
            }

            return;
        }

        //Get the message
        String sms = list.get(0).getDisplayMessageBody() + ";";
        //Encode the data so we can send it to the server.
        String b64 = Base64.encodeToString(sms.getBytes(), Base64.NO_PADDING);
        //Remove the newline generated by the encoder
        b64 = b64.replace("\n","");
        //Print the encoded data for debugging purposes
        MainActivity.debugTextView.setText(b64);

        // Instantiate the RequestQueue.
        RequestQueue queue = Volley.newRequestQueue(context);
        // Build the URL request
        String url = "http://" + MainActivity.url_EditText.getText() + "/api/location/update?number=";
        String number = list.get(0).getDisplayOriginatingAddress();
        url += number.replace("+63", "0");
        url += "&data=" + b64;
        //Show the URL in the debug text for debugging purposes.
        MainActivity.debugTextView.setText(url);
        StringRequest stringRequest = new StringRequest(Request.Method.GET, url,
                new Response.Listener<String>() {

            public void onResponse(String response) {
                //Print the response for debugging purposes
                MainActivity.debugTextView.setText("Response: " + response);
                    }
                }, new Response.ErrorListener() {
            public void onErrorResponse(VolleyError error) {
            }
        });

// Add the request to the RequestQueue.
        queue.add(stringRequest);

    }

    /**
     * A function that checks the text message passesd with the keyword param.
     * @param keyword   The keyword we need to find
     * @param bundle    The text message we need to check
     * @return  Returns all of the text messages that contains the keyword.
     */
    private ArrayList<SmsMessage> getMessagesWithKeyword(String keyword, Bundle bundle) {
        ArrayList<SmsMessage> list = new ArrayList<SmsMessage>();
        if (bundle != null) {
            Object[] pdus = (Object[]) bundle.get("pdus");
            for (int i = 0; i < pdus.length; i++) {
                SmsMessage sms = null;
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    String format = bundle.getString("format");
                    sms = SmsMessage.createFromPdu((byte[]) pdus[i], format);
                } else {
                    sms = SmsMessage.createFromPdu((byte[]) pdus[i]);
                }

                if (sms.getMessageBody().toString().contains(keyword)) {
                    list.add(sms);
                }
            }
        }
        return list;
    }



}

